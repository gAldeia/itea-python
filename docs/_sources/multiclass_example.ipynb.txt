{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Iris classification"
   ]
  },
  {
   "source": [
    "This notebook will walk through the process of using the ITEA for classification (``ITEA_classifier``) and interpreting the final expression with the ``itea.inspection`` tools."
   ],
   "cell_type": "markdown",
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "# automatically differentiable implementation of numpy\n",
    "import jax.numpy as jnp\n",
    "\n",
    "from sklearn import datasets\n",
    "\n",
    "from sklearn.model_selection import train_test_split\n",
    "from IPython.display         import display, Math, Latex\n",
    "\n",
    "from itea.classification import ITEA_classifier\n",
    "from itea.inspection     import *"
   ]
  },
  {
   "source": [
    "We will use the Iris data set in this example.\n",
    "\n",
    "This data set contains 3 different classes of Iris flowers and have 4 features: sepal width, sepal length, petal width and petal length.\n",
    "\n",
    "One example of each flower is illustred in the figure below.\n",
    "\n",
    "![](https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/iris-machinelearning.png)"
   ],
   "cell_type": "markdown",
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "gen \t min_fitness \t mean_fitness \t max_fitness \t remaining (s)\n",
      "0 \t 0.37 \t 0.8675999999999999 \t 0.93 \t 1min1seg\n",
      "5 \t 0.93 \t 0.93 \t 0.93 \t 0min52seg\n",
      "10 \t 0.93 \t 0.93 \t 0.93 \t 0min51seg\n",
      "15 \t 0.61 \t 0.9236 \t 0.93 \t 0min46seg\n",
      "20 \t 0.61 \t 0.9236 \t 0.93 \t 0min38seg\n",
      "25 \t 0.93 \t 0.93 \t 0.93 \t 0min31seg\n",
      "30 \t 0.93 \t 0.93 \t 0.93 \t 0min26seg\n",
      "35 \t 0.93 \t 0.93 \t 0.93 \t 0min18seg\n",
      "40 \t 0.93 \t 0.93 \t 0.93 \t 0min12seg\n",
      "45 \t 0.93 \t 0.93 \t 0.93 \t 0min5seg\n",
      "/mnt/c/Users/Guilherme Aldeia/Documents/github/interaction-transformation-evolutionary-algorithm/itea/inspection/_ITExpr_explainer.py:61: UserWarning: It wasn't specified a dict for tfuncs_dx. They will be automatically generated using Jax. For this, make sure that the tfuncs uses the jax.numpy instead of numpy to create the transformation functions. You can access the automatic derivatives with explainer.tfuncs_dx.\n",
      "  warnings.warn(\"It wasn't specified a dict for tfuncs_dx. \"\n"
     ]
    },
    {
     "output_type": "error",
     "ename": "TypeError",
     "evalue": "only integer scalar arrays can be converted to a scalar index",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-3-c35ea52f87ae>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     27\u001b[0m     \u001b[0mlabels\u001b[0m       \u001b[0;34m=\u001b[0m \u001b[0mlabels\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m     \u001b[0mrandom_state\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m42\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 29\u001b[0;31m ).fit(X_train, y_train)\n\u001b[0m",
      "\u001b[0;32m/mnt/c/Users/Guilherme Aldeia/Documents/github/interaction-transformation-evolutionary-algorithm/itea/classification/_ITEA_classifier.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y)\u001b[0m\n\u001b[1;32m    180\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclasses_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbestsol_\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mclasses_\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    181\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 182\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_explain_bestsol\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbestsol_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    183\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    184\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/mnt/c/Users/Guilherme Aldeia/Documents/github/interaction-transformation-evolutionary-algorithm/itea/_base/_BaseITEA.py\u001b[0m in \u001b[0;36m_explain_bestsol\u001b[0;34m(self, itexpr, X, y)\u001b[0m\n\u001b[1;32m    368\u001b[0m         ).fit(X, y)\n\u001b[1;32m    369\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 370\u001b[0;31m         \u001b[0mitexpr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mselected_features_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mexplainer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mselected_features\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    371\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    372\u001b[0m         \u001b[0mitexpr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfeature_importances_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mexplainer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0maverage_partial_effects\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/mnt/c/Users/Guilherme Aldeia/Documents/github/interaction-transformation-evolutionary-algorithm/itea/inspection/_ITExpr_explainer.py\u001b[0m in \u001b[0;36mselected_features\u001b[0;34m(self, idx)\u001b[0m\n\u001b[1;32m    136\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    137\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mitexpr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlabels\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m0\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0midx\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 138\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mitexpr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlabels\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mselected\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    139\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    140\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mselected\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: only integer scalar arrays can be converted to a scalar index"
     ]
    }
   ],
   "source": [
    "iris_data = datasets.load_iris()\n",
    "X, y      = iris_data['data'], iris_data['target']\n",
    "labels    = iris_data['feature_names']\n",
    "targets   = iris_data['target_names']\n",
    "\n",
    "# changing numbers to the class names\n",
    "y_targets = [targets[yi] for yi in y]\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(\n",
    "    X, y_targets, test_size=0.33, random_state=42)\n",
    "\n",
    "# Creating transformation functions for ITEA using jax.numpy\n",
    "# (so we don't need to analytically calculate its derivatives)\n",
    "tfuncs = {\n",
    "    'log'      : jnp.log,\n",
    "    'sqrt.abs' : lambda x: jnp.sqrt(jnp.abs(x)), \n",
    "    'id'       : lambda x: x\n",
    "}\n",
    "\n",
    "clf = ITEA_classifier(\n",
    "    gens         = 50,\n",
    "    popsize      = 50,\n",
    "    max_terms    = 5,\n",
    "    expolim      = (-2, -2),\n",
    "    verbose      = 5,\n",
    "    tfuncs       = tfuncs,\n",
    "    labels       = labels,\n",
    "    random_state = 42,\n",
    ").fit(X_train, y_train)"
   ]
  },
  {
   "source": [
    "Now that we have fitted the ITEA, our ``clf`` contains the ``bestsol_`` attribute, which is an fitted instance of ``ITExpr_classifier`` ready to be used."
   ],
   "cell_type": "markdown",
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "final_itexpr = clf.bestsol_\n",
    "\n",
    "final_itexpr.to_str(term_separator='\\n')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}